<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <meta name="google-site-verification" content="iplyfI0Y6pOe8NsNYwwrKe-QfSYamSeEhQiDFh93NiU">
    <title>Asynchronous HTTP requests with Scala and Dispatch - chris-rock
    </title>
    <link rel="alternate" href="http://lollyrock.com/feed.xml" type="application/rss+xml" title="fun &amp; sun">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50992958-1', 'lollyrock.com');
      ga('send', 'pageview');
    </script>
    <script type="text/javascript">
      !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
      
    </script>
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Asynchronous HTTP requests with Scala and Dispatch</h1>
        <p class="author">Written by <span class="author"><a href="mailto:chris@lollyrock.com">Christoph Hartmann</a></span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>Today, we use <span class="caps">REST</span> APIs everywhere. Quite often this requires the implementation of SDKs for specific languages. If you are going to write a SDK or you need to call a REST backend without the availability of a SDK, you need a framework to send HTTP requests. The cool thing about Scala is the fact that it has native support for <a href="http://docs.scala-lang.org/overviews/core/futures.html">Futures (aka Promises)</a>. By using futures, you simplify your&nbsp;life:</p>
<ul>
<li>the application does not&nbsp;block</li>
<li>the application can handle more parallel&nbsp;requests</li>
<li>you do not need a complex threading&nbsp;model</li>
</ul>
<p>In Scala, <a href="http://dispatch.databinder.net/Dispatch.html">Dispatch</a> is an asynchronous http library. Letâ€™s do a simple request with&nbsp;Futures.</p>
<h2 id="plain-http-request">Plain <span class="caps">HTTP</span>&nbsp;request</h2>
<pre><code class="lang-scala"><span class="keyword">import</span> dispatch._, <span class="type">Defaults</span>._
<span class="keyword">import</span> scala.util.{<span class="type">Success</span>, <span class="type">Failure</span>}

<span class="class"><span class="keyword">object</span> <span class="title">DispatchTest</span> </span>{

  <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]) {
    <span class="keyword">val</span> svc = url(<span class="string">"http://www.wikipedia.org/"</span>);
    <span class="keyword">val</span> response : <span class="type">Future</span>[<span class="type">String</span>] = <span class="type">Http</span>(svc <span class="type"><span class="caps">OK</span></span> as.<span class="type">String</span>)

    response onComplete {
      <span class="keyword">case</span> <span class="type">Success</span>(content) =&gt; {
        println(<span class="string">"Successful response"</span> + content)
      }
      <span class="keyword">case</span> <span class="type">Failure</span>(t) =&gt; {
        println(<span class="string">"An error has occurred: "</span> + t.getMessage)
      }
    }
  }
}
</code></pre>
<h2 id="http-request-with-redirect"><span class="caps">HTTP</span> request with&nbsp;redirect</h2>
<p>It is common that <span class="caps">HTTP</span> endpoints use redirects. By default <code>Dispatch</code> does not follow these redirects. You need to configure the Http instance to enable the redirect handling by using <code>Http.configure(_ setFollowRedirects true)(svc OK as.String)</code>. The previous example with redirect looks&nbsp;like:</p>
<pre><code class="lang-scala"><span class="keyword">import</span> dispatch._, <span class="type">Defaults</span>._
<span class="keyword">import</span> scala.util.{<span class="type">Success</span>, <span class="type">Failure</span>}

<span class="class"><span class="keyword">object</span> <span class="title">DispatchTest</span> </span>{

  <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]) {

    <span class="keyword">val</span> svc = url(<span class="string">"http://www.wikipedia.com"</span>);
    <span class="keyword">val</span> response : <span class="type">Future</span>[<span class="type">String</span>] = <span class="type">Http</span>.configure(_ setFollowRedirects <span class="literal">true</span>)(svc <span class="type"><span class="caps">OK</span></span> as.<span class="type">String</span>)

    response onComplete {
      <span class="keyword">case</span> <span class="type">Success</span>(content) =&gt; {
        println(<span class="string">"Successful response"</span> + content)
      }
      <span class="keyword">case</span> <span class="type">Failure</span>(t) =&gt; {
        println(<span class="string">"An error has occured: "</span> + t.getMessage)
      }
    }
  }
}
</code></pre>
<h2 id="http-request-with-basic-authentication"><span class="caps">HTTP</span> request with basic&nbsp;authentication</h2>
<p>If you require basic authentication for your http requests, use <code>.as_!()</code></p>
<pre><code class="lang-scala"><span class="keyword">val</span> svc = url(<span class="string">"http://www.wikipedia.com"</span>).as_!(<span class="string">"user"</span>, <span class="string">"password"</span>)
</code></pre>
<h2 id="parse-json-response">Parse <span class="caps">JSON</span>&nbsp;response</h2>
<p>Nowadays nearly all <span class="caps">REST</span> endpoints use JSON responses. <a href="http://argonaut.io/">Argonaut</a> is a Scala toolkit for <span class="caps">HTTP</span> handling. It uses many functional features of the Scala and integrates very well into the&nbsp;language.</p>
<p>For quick parsing or where a predefined structure is not available, you can parse specific&nbsp;fields:</p>
<pre><code class="lang-scala">import scalaz._, Scalaz._
import argonaut._, Argonaut._

val json = """
  { "name" : "Toddler", "age" : 2, "greeting": "gurgle!" }
"""

// extract a simple field
val greeting1: String =
Parse.parseWith(jsonString, _.field("greeting").flatMap(_.string).getOrElse(null), msg =&gt; msg)
</code></pre>
<p>This works very well at places where you have to deal with changing data structures. Quite often <span class="caps">REST</span> APIs deliver a well-defined structure, that can be used for parsing. Assume you get user data like the&nbsp;following:</p>
<pre><code class="lang-json">{
  <span class="attr">"dn"</span>:<span class="string">"uid=chris,ou=Users,dc=lollyrock,dc=com"</span>,
  <span class="attr">"controls"</span>:[],
  <span class="attr">"cn"</span>:<span class="string">"Chris Rock"</span>,
  <span class="attr">"givenName"</span>:<span class="string">"Chris"</span>,
  <span class="attr">"l"</span>:<span class="string">"Berlin"</span>,
  <span class="attr">"mail"</span>:<span class="string">"chris@lollyrock.com"</span>,
  <span class="attr">"uid"</span>: <span class="string">"chris"</span> ,
  <span class="attr">"displayName"</span>:<span class="string">"ch.hartmann"</span>,
  <span class="attr">"o"</span>:<span class="string">"Rock Inc."</span>
}
</code></pre>
<p>At first we need a structure to store the parsed values. In Scala <code>Case Classes</code> are perfect for this&nbsp;need:</p>
<pre><code class="lang-scala"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">
   dn: <span class="type">String</span>,
   cn: <span class="type">String</span>,
   givenName: <span class="type">String</span>,
   l: <span class="type">String</span>,
   mail: <span class="type">String</span>,
   displayName: <span class="type">String</span>,
   o: <span class="type">String</span></span>)</span>
</code></pre>
<p>The following example demonstrates the parsing of <span class="caps">JSON</span> data into a predefined case&nbsp;class.</p>
<pre><code>import scalaz._, Scalaz._
import argonaut._, Argonaut._

// data structure, json will be converted into this class
case class User(
   dn: String,
   cn: String,
   givenName: String,
   l: String,
   mail: String,
   displayName: String,
   o: String)


object UserParser {

  // use the implicit json conversion of Argonaut
  // more information at http://argonaut.io/doc/parsing/
  implicit def UserCodecJson: CodecJson[User] =
    // the 9 represents the amount of arguments
    casecodec9(User.apply, User.unapply)(&quot;dn&quot;, &quot;cn&quot;, &quot;givenName&quot;,&quot;l&quot;, &quot;mail&quot;, &quot;uid&quot;, &quot;displayName&quot;, &quot;o&quot;, &quot;plan&quot;)

  // method to use argonaut parse
  def parse(data: String) : Option[User] = {
    Parse.decodeOption[User](data)
  }

  // simple app to test JSON parsing
  def main(args: Array[String]) {

    // json input data
    var jsonString =
      &quot;&quot;&quot;
        | {&quot;dn&quot;:&quot;uid=chris,ou=Users,dc=lollyrock,dc=com&quot;,&quot;controls&quot;:[],&quot;cn&quot;:&quot;Chris Rock&quot;,&quot;givenName&quot;:&quot;Chris&quot;,&quot;l&quot;:&quot;Berlin&quot;,&quot;mail&quot;:&quot;chris@lollyrock.com&quot;,&quot;uid&quot;: &quot;chris&quot; ,&quot;displayName&quot;:&quot;ch.hartmann&quot;,&quot;o&quot;:&quot;Rock Inc.&quot;}
      &quot;&quot;&quot;.stripMargin

    // parse json content
    val userdata: Option[User] = parse(jsonString)

    // print specific values
    val usr = userdata.get
    println (usr.dn)
    println (usr.displayName)

  }

}
</code></pre><p>The combination of <code>Dispatch</code> and <code>Argonout</code> provides an efficient way to do <span class="caps">HTTP</span> calls and evaluate the response in Scala. Since we are using Futures, the environment can handle more requests at the same time and the code is easier to read than a complex threading&nbsp;system.</p>
<p>Cheers</p>
<p>Chris </p>
<p>If you have any questions contact me via <a href="https://twitter.com/chri_hartmann">Twitter @chri_hartmann</a> or <a href="https://github.com/chris-rock">Github</a></p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="social center">
          <div class="network"><a href="javascript:window.location=%22http://news.ycombinator.com/submitlink?u=%22+encodeURIComponent(document.location)+%22&amp;amp;t=%22+encodeURIComponent(document.title)" class="hn-link">Discuss on Hacker News</a></div>
          <div class="network twitter"><a https://twitter.com/share data-via="chri_hartmann" data-count="none" class="twitter-share-button">Tweet</a></div>
        </div>
        <div class="nav"><a href="/">Â« Full blog</a></div>
        <section class="about">
        </section>
        <section class="copy">
          <p>&copy; 2018 Christoph Hartmann &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>